// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: rules.proto
// Protobuf C++ Version: 5.29.3

#ifndef rules_2eproto_2epb_2eh
#define rules_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_rules_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_rules_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_rules_2eproto;
namespace dsl {
class Comparison;
struct ComparisonDefaultTypeInternal;
extern ComparisonDefaultTypeInternal _Comparison_default_instance_;
class Expr;
struct ExprDefaultTypeInternal;
extern ExprDefaultTypeInternal _Expr_default_instance_;
class Logical;
struct LogicalDefaultTypeInternal;
extern LogicalDefaultTypeInternal _Logical_default_instance_;
class NotExpr;
struct NotExprDefaultTypeInternal;
extern NotExprDefaultTypeInternal _NotExpr_default_instance_;
class RangeCheck;
struct RangeCheckDefaultTypeInternal;
extern RangeCheckDefaultTypeInternal _RangeCheck_default_instance_;
class Rule;
struct RuleDefaultTypeInternal;
extern RuleDefaultTypeInternal _Rule_default_instance_;
class RuleSet;
struct RuleSetDefaultTypeInternal;
extern RuleSetDefaultTypeInternal _RuleSet_default_instance_;
}  // namespace dsl
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace dsl {
enum SeverityType : int {
  WARN = 0,
  ERROR = 1,
  SeverityType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SeverityType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SeverityType_IsValid(int value);
extern const uint32_t SeverityType_internal_data_[];
constexpr SeverityType SeverityType_MIN = static_cast<SeverityType>(0);
constexpr SeverityType SeverityType_MAX = static_cast<SeverityType>(1);
constexpr int SeverityType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
SeverityType_descriptor();
template <typename T>
const std::string& SeverityType_Name(T value) {
  static_assert(std::is_same<T, SeverityType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SeverityType_Name().");
  return SeverityType_Name(static_cast<SeverityType>(value));
}
template <>
inline const std::string& SeverityType_Name(SeverityType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SeverityType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool SeverityType_Parse(absl::string_view name, SeverityType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SeverityType>(
      SeverityType_descriptor(), name, value);
}
enum ComparisonOpType : int {
  UNSPECIFIED = 0,
  EQ = 1,
  NE = 2,
  GT = 3,
  GE = 4,
  LT = 5,
  LE = 6,
  ComparisonOpType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ComparisonOpType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ComparisonOpType_IsValid(int value);
extern const uint32_t ComparisonOpType_internal_data_[];
constexpr ComparisonOpType ComparisonOpType_MIN = static_cast<ComparisonOpType>(0);
constexpr ComparisonOpType ComparisonOpType_MAX = static_cast<ComparisonOpType>(6);
constexpr int ComparisonOpType_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
ComparisonOpType_descriptor();
template <typename T>
const std::string& ComparisonOpType_Name(T value) {
  static_assert(std::is_same<T, ComparisonOpType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ComparisonOpType_Name().");
  return ComparisonOpType_Name(static_cast<ComparisonOpType>(value));
}
template <>
inline const std::string& ComparisonOpType_Name(ComparisonOpType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ComparisonOpType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool ComparisonOpType_Parse(absl::string_view name, ComparisonOpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ComparisonOpType>(
      ComparisonOpType_descriptor(), name, value);
}
enum LogicOpType : int {
  AND = 0,
  OR = 1,
  LogicOpType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LogicOpType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LogicOpType_IsValid(int value);
extern const uint32_t LogicOpType_internal_data_[];
constexpr LogicOpType LogicOpType_MIN = static_cast<LogicOpType>(0);
constexpr LogicOpType LogicOpType_MAX = static_cast<LogicOpType>(1);
constexpr int LogicOpType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
LogicOpType_descriptor();
template <typename T>
const std::string& LogicOpType_Name(T value) {
  static_assert(std::is_same<T, LogicOpType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LogicOpType_Name().");
  return LogicOpType_Name(static_cast<LogicOpType>(value));
}
template <>
inline const std::string& LogicOpType_Name(LogicOpType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LogicOpType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool LogicOpType_Parse(absl::string_view name, LogicOpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogicOpType>(
      LogicOpType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class RangeCheck final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dsl.RangeCheck) */ {
 public:
  inline RangeCheck() : RangeCheck(nullptr) {}
  ~RangeCheck() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RangeCheck* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RangeCheck));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RangeCheck(
      ::google::protobuf::internal::ConstantInitialized);

  inline RangeCheck(const RangeCheck& from) : RangeCheck(nullptr, from) {}
  inline RangeCheck(RangeCheck&& from) noexcept
      : RangeCheck(nullptr, std::move(from)) {}
  inline RangeCheck& operator=(const RangeCheck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeCheck& operator=(RangeCheck&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangeCheck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangeCheck* internal_default_instance() {
    return reinterpret_cast<const RangeCheck*>(
        &_RangeCheck_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(RangeCheck& a, RangeCheck& b) { a.Swap(&b); }
  inline void Swap(RangeCheck* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangeCheck* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangeCheck* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RangeCheck>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RangeCheck& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RangeCheck& from) { RangeCheck::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RangeCheck* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dsl.RangeCheck"; }

 protected:
  explicit RangeCheck(::google::protobuf::Arena* arena);
  RangeCheck(::google::protobuf::Arena* arena, const RangeCheck& from);
  RangeCheck(::google::protobuf::Arena* arena, RangeCheck&& from) noexcept
      : RangeCheck(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kColumnFieldNumber = 1,
    kLowFieldNumber = 2,
    kHighFieldNumber = 3,
  };
  // string column = 1;
  void clear_column() ;
  const std::string& column() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_column(Arg_&& arg, Args_... args);
  std::string* mutable_column();
  PROTOBUF_NODISCARD std::string* release_column();
  void set_allocated_column(std::string* value);

  private:
  const std::string& _internal_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column(
      const std::string& value);
  std::string* _internal_mutable_column();

  public:
  // double low = 2;
  void clear_low() ;
  double low() const;
  void set_low(double value);

  private:
  double _internal_low() const;
  void _internal_set_low(double value);

  public:
  // double high = 3;
  void clear_high() ;
  double high() const;
  void set_high(double value);

  private:
  double _internal_high() const;
  void _internal_set_high(double value);

  public:
  // @@protoc_insertion_point(class_scope:dsl.RangeCheck)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      29, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RangeCheck& from_msg);
    ::google::protobuf::internal::ArenaStringPtr column_;
    double low_;
    double high_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rules_2eproto;
};
// -------------------------------------------------------------------

class Comparison final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dsl.Comparison) */ {
 public:
  inline Comparison() : Comparison(nullptr) {}
  ~Comparison() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Comparison* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Comparison));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Comparison(
      ::google::protobuf::internal::ConstantInitialized);

  inline Comparison(const Comparison& from) : Comparison(nullptr, from) {}
  inline Comparison(Comparison&& from) noexcept
      : Comparison(nullptr, std::move(from)) {}
  inline Comparison& operator=(const Comparison& from) {
    CopyFrom(from);
    return *this;
  }
  inline Comparison& operator=(Comparison&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Comparison& default_instance() {
    return *internal_default_instance();
  }
  static inline const Comparison* internal_default_instance() {
    return reinterpret_cast<const Comparison*>(
        &_Comparison_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Comparison& a, Comparison& b) { a.Swap(&b); }
  inline void Swap(Comparison* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Comparison* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Comparison* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Comparison>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Comparison& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Comparison& from) { Comparison::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Comparison* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dsl.Comparison"; }

 protected:
  explicit Comparison(::google::protobuf::Arena* arena);
  Comparison(::google::protobuf::Arena* arena, const Comparison& from);
  Comparison(::google::protobuf::Arena* arena, Comparison&& from) noexcept
      : Comparison(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kColumnFieldNumber = 1,
    kValueFieldNumber = 3,
    kOpFieldNumber = 2,
  };
  // string column = 1;
  void clear_column() ;
  const std::string& column() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_column(Arg_&& arg, Args_... args);
  std::string* mutable_column();
  PROTOBUF_NODISCARD std::string* release_column();
  void set_allocated_column(std::string* value);

  private:
  const std::string& _internal_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column(
      const std::string& value);
  std::string* _internal_mutable_column();

  public:
  // string value = 3;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // .dsl.ComparisonOpType op = 2;
  void clear_op() ;
  ::dsl::ComparisonOpType op() const;
  void set_op(::dsl::ComparisonOpType value);

  private:
  ::dsl::ComparisonOpType _internal_op() const;
  void _internal_set_op(::dsl::ComparisonOpType value);

  public:
  // @@protoc_insertion_point(class_scope:dsl.Comparison)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      34, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Comparison& from_msg);
    ::google::protobuf::internal::ArenaStringPtr column_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    int op_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rules_2eproto;
};
// -------------------------------------------------------------------

class Expr final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dsl.Expr) */ {
 public:
  inline Expr() : Expr(nullptr) {}
  ~Expr() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expr* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expr));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expr(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expr(const Expr& from) : Expr(nullptr, from) {}
  inline Expr(Expr&& from) noexcept
      : Expr(nullptr, std::move(from)) {}
  inline Expr& operator=(const Expr& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expr& operator=(Expr&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expr& default_instance() {
    return *internal_default_instance();
  }
  enum ExprKindCase {
    kComparison = 1,
    kRange = 2,
    kLogical = 3,
    kNotExpr = 4,
    EXPR_KIND_NOT_SET = 0,
  };
  static inline const Expr* internal_default_instance() {
    return reinterpret_cast<const Expr*>(
        &_Expr_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Expr& a, Expr& b) { a.Swap(&b); }
  inline void Swap(Expr* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expr* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expr& from) { Expr::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expr* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dsl.Expr"; }

 protected:
  explicit Expr(::google::protobuf::Arena* arena);
  Expr(::google::protobuf::Arena* arena, const Expr& from);
  Expr(::google::protobuf::Arena* arena, Expr&& from) noexcept
      : Expr(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kComparisonFieldNumber = 1,
    kRangeFieldNumber = 2,
    kLogicalFieldNumber = 3,
    kNotExprFieldNumber = 4,
  };
  // .dsl.Comparison comparison = 1;
  bool has_comparison() const;
  private:
  bool _internal_has_comparison() const;

  public:
  void clear_comparison() ;
  const ::dsl::Comparison& comparison() const;
  PROTOBUF_NODISCARD ::dsl::Comparison* release_comparison();
  ::dsl::Comparison* mutable_comparison();
  void set_allocated_comparison(::dsl::Comparison* value);
  void unsafe_arena_set_allocated_comparison(::dsl::Comparison* value);
  ::dsl::Comparison* unsafe_arena_release_comparison();

  private:
  const ::dsl::Comparison& _internal_comparison() const;
  ::dsl::Comparison* _internal_mutable_comparison();

  public:
  // .dsl.RangeCheck range = 2;
  bool has_range() const;
  private:
  bool _internal_has_range() const;

  public:
  void clear_range() ;
  const ::dsl::RangeCheck& range() const;
  PROTOBUF_NODISCARD ::dsl::RangeCheck* release_range();
  ::dsl::RangeCheck* mutable_range();
  void set_allocated_range(::dsl::RangeCheck* value);
  void unsafe_arena_set_allocated_range(::dsl::RangeCheck* value);
  ::dsl::RangeCheck* unsafe_arena_release_range();

  private:
  const ::dsl::RangeCheck& _internal_range() const;
  ::dsl::RangeCheck* _internal_mutable_range();

  public:
  // .dsl.Logical logical = 3;
  bool has_logical() const;
  private:
  bool _internal_has_logical() const;

  public:
  void clear_logical() ;
  const ::dsl::Logical& logical() const;
  PROTOBUF_NODISCARD ::dsl::Logical* release_logical();
  ::dsl::Logical* mutable_logical();
  void set_allocated_logical(::dsl::Logical* value);
  void unsafe_arena_set_allocated_logical(::dsl::Logical* value);
  ::dsl::Logical* unsafe_arena_release_logical();

  private:
  const ::dsl::Logical& _internal_logical() const;
  ::dsl::Logical* _internal_mutable_logical();

  public:
  // .dsl.NotExpr not_expr = 4;
  bool has_not_expr() const;
  private:
  bool _internal_has_not_expr() const;

  public:
  void clear_not_expr() ;
  const ::dsl::NotExpr& not_expr() const;
  PROTOBUF_NODISCARD ::dsl::NotExpr* release_not_expr();
  ::dsl::NotExpr* mutable_not_expr();
  void set_allocated_not_expr(::dsl::NotExpr* value);
  void unsafe_arena_set_allocated_not_expr(::dsl::NotExpr* value);
  ::dsl::NotExpr* unsafe_arena_release_not_expr();

  private:
  const ::dsl::NotExpr& _internal_not_expr() const;
  ::dsl::NotExpr* _internal_mutable_not_expr();

  public:
  void clear_expr_kind();
  ExprKindCase expr_kind_case() const;
  // @@protoc_insertion_point(class_scope:dsl.Expr)
 private:
  class _Internal;
  void set_has_comparison();
  void set_has_range();
  void set_has_logical();
  void set_has_not_expr();
  inline bool has_expr_kind() const;
  inline void clear_has_expr_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expr& from_msg);
    union ExprKindUnion {
      constexpr ExprKindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::dsl::Comparison* comparison_;
      ::dsl::RangeCheck* range_;
      ::dsl::Logical* logical_;
      ::dsl::NotExpr* not_expr_;
    } expr_kind_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rules_2eproto;
};
// -------------------------------------------------------------------

class Logical final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dsl.Logical) */ {
 public:
  inline Logical() : Logical(nullptr) {}
  ~Logical() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Logical* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Logical));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Logical(
      ::google::protobuf::internal::ConstantInitialized);

  inline Logical(const Logical& from) : Logical(nullptr, from) {}
  inline Logical(Logical&& from) noexcept
      : Logical(nullptr, std::move(from)) {}
  inline Logical& operator=(const Logical& from) {
    CopyFrom(from);
    return *this;
  }
  inline Logical& operator=(Logical&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Logical& default_instance() {
    return *internal_default_instance();
  }
  static inline const Logical* internal_default_instance() {
    return reinterpret_cast<const Logical*>(
        &_Logical_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Logical& a, Logical& b) { a.Swap(&b); }
  inline void Swap(Logical* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Logical* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Logical* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Logical>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Logical& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Logical& from) { Logical::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Logical* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dsl.Logical"; }

 protected:
  explicit Logical(::google::protobuf::Arena* arena);
  Logical(::google::protobuf::Arena* arena, const Logical& from);
  Logical(::google::protobuf::Arena* arena, Logical&& from) noexcept
      : Logical(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOperandsFieldNumber = 2,
    kOpFieldNumber = 1,
  };
  // repeated .dsl.Expr operands = 2;
  int operands_size() const;
  private:
  int _internal_operands_size() const;

  public:
  void clear_operands() ;
  ::dsl::Expr* mutable_operands(int index);
  ::google::protobuf::RepeatedPtrField<::dsl::Expr>* mutable_operands();

  private:
  const ::google::protobuf::RepeatedPtrField<::dsl::Expr>& _internal_operands() const;
  ::google::protobuf::RepeatedPtrField<::dsl::Expr>* _internal_mutable_operands();
  public:
  const ::dsl::Expr& operands(int index) const;
  ::dsl::Expr* add_operands();
  const ::google::protobuf::RepeatedPtrField<::dsl::Expr>& operands() const;
  // .dsl.LogicOpType op = 1;
  void clear_op() ;
  ::dsl::LogicOpType op() const;
  void set_op(::dsl::LogicOpType value);

  private:
  ::dsl::LogicOpType _internal_op() const;
  void _internal_set_op(::dsl::LogicOpType value);

  public:
  // @@protoc_insertion_point(class_scope:dsl.Logical)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Logical& from_msg);
    ::google::protobuf::RepeatedPtrField< ::dsl::Expr > operands_;
    int op_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rules_2eproto;
};
// -------------------------------------------------------------------

class NotExpr final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dsl.NotExpr) */ {
 public:
  inline NotExpr() : NotExpr(nullptr) {}
  ~NotExpr() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NotExpr* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NotExpr));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotExpr(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotExpr(const NotExpr& from) : NotExpr(nullptr, from) {}
  inline NotExpr(NotExpr&& from) noexcept
      : NotExpr(nullptr, std::move(from)) {}
  inline NotExpr& operator=(const NotExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotExpr& operator=(NotExpr&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotExpr* internal_default_instance() {
    return reinterpret_cast<const NotExpr*>(
        &_NotExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(NotExpr& a, NotExpr& b) { a.Swap(&b); }
  inline void Swap(NotExpr* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotExpr* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NotExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotExpr& from) { NotExpr::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NotExpr* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dsl.NotExpr"; }

 protected:
  explicit NotExpr(::google::protobuf::Arena* arena);
  NotExpr(::google::protobuf::Arena* arena, const NotExpr& from);
  NotExpr(::google::protobuf::Arena* arena, NotExpr&& from) noexcept
      : NotExpr(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExprFieldNumber = 1,
  };
  // .dsl.Expr expr = 1;
  bool has_expr() const;
  void clear_expr() ;
  const ::dsl::Expr& expr() const;
  PROTOBUF_NODISCARD ::dsl::Expr* release_expr();
  ::dsl::Expr* mutable_expr();
  void set_allocated_expr(::dsl::Expr* value);
  void unsafe_arena_set_allocated_expr(::dsl::Expr* value);
  ::dsl::Expr* unsafe_arena_release_expr();

  private:
  const ::dsl::Expr& _internal_expr() const;
  ::dsl::Expr* _internal_mutable_expr();

  public:
  // @@protoc_insertion_point(class_scope:dsl.NotExpr)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NotExpr& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::dsl::Expr* expr_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rules_2eproto;
};
// -------------------------------------------------------------------

class Rule final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dsl.Rule) */ {
 public:
  inline Rule() : Rule(nullptr) {}
  ~Rule() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Rule* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Rule));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Rule(
      ::google::protobuf::internal::ConstantInitialized);

  inline Rule(const Rule& from) : Rule(nullptr, from) {}
  inline Rule(Rule&& from) noexcept
      : Rule(nullptr, std::move(from)) {}
  inline Rule& operator=(const Rule& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule& operator=(Rule&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rule* internal_default_instance() {
    return reinterpret_cast<const Rule*>(
        &_Rule_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Rule& a, Rule& b) { a.Swap(&b); }
  inline void Swap(Rule* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Rule>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Rule& from) { Rule::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Rule* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dsl.Rule"; }

 protected:
  explicit Rule(::google::protobuf::Arena* arena);
  Rule(::google::protobuf::Arena* arena, const Rule& from);
  Rule(::google::protobuf::Arena* arena, Rule&& from) noexcept
      : Rule(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLabelFieldNumber = 2,
    kConditionFieldNumber = 3,
    kSeverityFieldNumber = 1,
  };
  // string label = 2;
  void clear_label() ;
  const std::string& label() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_label(Arg_&& arg, Args_... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* value);

  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(
      const std::string& value);
  std::string* _internal_mutable_label();

  public:
  // .dsl.Expr condition = 3;
  bool has_condition() const;
  void clear_condition() ;
  const ::dsl::Expr& condition() const;
  PROTOBUF_NODISCARD ::dsl::Expr* release_condition();
  ::dsl::Expr* mutable_condition();
  void set_allocated_condition(::dsl::Expr* value);
  void unsafe_arena_set_allocated_condition(::dsl::Expr* value);
  ::dsl::Expr* unsafe_arena_release_condition();

  private:
  const ::dsl::Expr& _internal_condition() const;
  ::dsl::Expr* _internal_mutable_condition();

  public:
  // .dsl.SeverityType severity = 1;
  void clear_severity() ;
  ::dsl::SeverityType severity() const;
  void set_severity(::dsl::SeverityType value);

  private:
  ::dsl::SeverityType _internal_severity() const;
  void _internal_set_severity(::dsl::SeverityType value);

  public:
  // @@protoc_insertion_point(class_scope:dsl.Rule)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      22, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Rule& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr label_;
    ::dsl::Expr* condition_;
    int severity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rules_2eproto;
};
// -------------------------------------------------------------------

class RuleSet final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dsl.RuleSet) */ {
 public:
  inline RuleSet() : RuleSet(nullptr) {}
  ~RuleSet() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RuleSet* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RuleSet));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RuleSet(
      ::google::protobuf::internal::ConstantInitialized);

  inline RuleSet(const RuleSet& from) : RuleSet(nullptr, from) {}
  inline RuleSet(RuleSet&& from) noexcept
      : RuleSet(nullptr, std::move(from)) {}
  inline RuleSet& operator=(const RuleSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuleSet& operator=(RuleSet&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RuleSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const RuleSet* internal_default_instance() {
    return reinterpret_cast<const RuleSet*>(
        &_RuleSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(RuleSet& a, RuleSet& b) { a.Swap(&b); }
  inline void Swap(RuleSet* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RuleSet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RuleSet* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RuleSet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RuleSet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RuleSet& from) { RuleSet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RuleSet* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dsl.RuleSet"; }

 protected:
  explicit RuleSet(::google::protobuf::Arena* arena);
  RuleSet(::google::protobuf::Arena* arena, const RuleSet& from);
  RuleSet(::google::protobuf::Arena* arena, RuleSet&& from) noexcept
      : RuleSet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRulesFieldNumber = 1,
  };
  // repeated .dsl.Rule rules = 1;
  int rules_size() const;
  private:
  int _internal_rules_size() const;

  public:
  void clear_rules() ;
  ::dsl::Rule* mutable_rules(int index);
  ::google::protobuf::RepeatedPtrField<::dsl::Rule>* mutable_rules();

  private:
  const ::google::protobuf::RepeatedPtrField<::dsl::Rule>& _internal_rules() const;
  ::google::protobuf::RepeatedPtrField<::dsl::Rule>* _internal_mutable_rules();
  public:
  const ::dsl::Rule& rules(int index) const;
  ::dsl::Rule* add_rules();
  const ::google::protobuf::RepeatedPtrField<::dsl::Rule>& rules() const;
  // @@protoc_insertion_point(class_scope:dsl.RuleSet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RuleSet& from_msg);
    ::google::protobuf::RepeatedPtrField< ::dsl::Rule > rules_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rules_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RuleSet

// repeated .dsl.Rule rules = 1;
inline int RuleSet::_internal_rules_size() const {
  return _internal_rules().size();
}
inline int RuleSet::rules_size() const {
  return _internal_rules_size();
}
inline void RuleSet::clear_rules() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rules_.Clear();
}
inline ::dsl::Rule* RuleSet::mutable_rules(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dsl.RuleSet.rules)
  return _internal_mutable_rules()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dsl::Rule>* RuleSet::mutable_rules()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dsl.RuleSet.rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_rules();
}
inline const ::dsl::Rule& RuleSet::rules(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dsl.RuleSet.rules)
  return _internal_rules().Get(index);
}
inline ::dsl::Rule* RuleSet::add_rules() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dsl::Rule* _add = _internal_mutable_rules()->Add();
  // @@protoc_insertion_point(field_add:dsl.RuleSet.rules)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dsl::Rule>& RuleSet::rules() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dsl.RuleSet.rules)
  return _internal_rules();
}
inline const ::google::protobuf::RepeatedPtrField<::dsl::Rule>&
RuleSet::_internal_rules() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rules_;
}
inline ::google::protobuf::RepeatedPtrField<::dsl::Rule>*
RuleSet::_internal_mutable_rules() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.rules_;
}

// -------------------------------------------------------------------

// Rule

// .dsl.SeverityType severity = 1;
inline void Rule::clear_severity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.severity_ = 0;
}
inline ::dsl::SeverityType Rule::severity() const {
  // @@protoc_insertion_point(field_get:dsl.Rule.severity)
  return _internal_severity();
}
inline void Rule::set_severity(::dsl::SeverityType value) {
  _internal_set_severity(value);
  // @@protoc_insertion_point(field_set:dsl.Rule.severity)
}
inline ::dsl::SeverityType Rule::_internal_severity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dsl::SeverityType>(_impl_.severity_);
}
inline void Rule::_internal_set_severity(::dsl::SeverityType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.severity_ = value;
}

// string label = 2;
inline void Rule::clear_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.label_.ClearToEmpty();
}
inline const std::string& Rule::label() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dsl.Rule.label)
  return _internal_label();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule::set_label(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.label_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dsl.Rule.label)
}
inline std::string* Rule::mutable_label() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:dsl.Rule.label)
  return _s;
}
inline const std::string& Rule::_internal_label() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.label_.Get();
}
inline void Rule::_internal_set_label(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.label_.Set(value, GetArena());
}
inline std::string* Rule::_internal_mutable_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.label_.Mutable( GetArena());
}
inline std::string* Rule::release_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dsl.Rule.label)
  return _impl_.label_.Release();
}
inline void Rule::set_allocated_label(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.label_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dsl.Rule.label)
}

// .dsl.Expr condition = 3;
inline bool Rule::has_condition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.condition_ != nullptr);
  return value;
}
inline void Rule::clear_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.condition_ != nullptr) _impl_.condition_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dsl::Expr& Rule::_internal_condition() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dsl::Expr* p = _impl_.condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::dsl::Expr&>(::dsl::_Expr_default_instance_);
}
inline const ::dsl::Expr& Rule::condition() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dsl.Rule.condition)
  return _internal_condition();
}
inline void Rule::unsafe_arena_set_allocated_condition(::dsl::Expr* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.condition_);
  }
  _impl_.condition_ = reinterpret_cast<::dsl::Expr*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dsl.Rule.condition)
}
inline ::dsl::Expr* Rule::release_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dsl::Expr* released = _impl_.condition_;
  _impl_.condition_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dsl::Expr* Rule::unsafe_arena_release_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dsl.Rule.condition)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dsl::Expr* temp = _impl_.condition_;
  _impl_.condition_ = nullptr;
  return temp;
}
inline ::dsl::Expr* Rule::_internal_mutable_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.condition_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dsl::Expr>(GetArena());
    _impl_.condition_ = reinterpret_cast<::dsl::Expr*>(p);
  }
  return _impl_.condition_;
}
inline ::dsl::Expr* Rule::mutable_condition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dsl::Expr* _msg = _internal_mutable_condition();
  // @@protoc_insertion_point(field_mutable:dsl.Rule.condition)
  return _msg;
}
inline void Rule::set_allocated_condition(::dsl::Expr* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.condition_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.condition_ = reinterpret_cast<::dsl::Expr*>(value);
  // @@protoc_insertion_point(field_set_allocated:dsl.Rule.condition)
}

// -------------------------------------------------------------------

// Expr

// .dsl.Comparison comparison = 1;
inline bool Expr::has_comparison() const {
  return expr_kind_case() == kComparison;
}
inline bool Expr::_internal_has_comparison() const {
  return expr_kind_case() == kComparison;
}
inline void Expr::set_has_comparison() {
  _impl_._oneof_case_[0] = kComparison;
}
inline void Expr::clear_comparison() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (expr_kind_case() == kComparison) {
    if (GetArena() == nullptr) {
      delete _impl_.expr_kind_.comparison_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.expr_kind_.comparison_);
    }
    clear_has_expr_kind();
  }
}
inline ::dsl::Comparison* Expr::release_comparison() {
  // @@protoc_insertion_point(field_release:dsl.Expr.comparison)
  if (expr_kind_case() == kComparison) {
    clear_has_expr_kind();
    auto* temp = _impl_.expr_kind_.comparison_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_kind_.comparison_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dsl::Comparison& Expr::_internal_comparison() const {
  return expr_kind_case() == kComparison ? *_impl_.expr_kind_.comparison_ : reinterpret_cast<::dsl::Comparison&>(::dsl::_Comparison_default_instance_);
}
inline const ::dsl::Comparison& Expr::comparison() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dsl.Expr.comparison)
  return _internal_comparison();
}
inline ::dsl::Comparison* Expr::unsafe_arena_release_comparison() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dsl.Expr.comparison)
  if (expr_kind_case() == kComparison) {
    clear_has_expr_kind();
    auto* temp = _impl_.expr_kind_.comparison_;
    _impl_.expr_kind_.comparison_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_comparison(::dsl::Comparison* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_expr_kind();
  if (value) {
    set_has_comparison();
    _impl_.expr_kind_.comparison_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dsl.Expr.comparison)
}
inline ::dsl::Comparison* Expr::_internal_mutable_comparison() {
  if (expr_kind_case() != kComparison) {
    clear_expr_kind();
    set_has_comparison();
    _impl_.expr_kind_.comparison_ =
        ::google::protobuf::Message::DefaultConstruct<::dsl::Comparison>(GetArena());
  }
  return _impl_.expr_kind_.comparison_;
}
inline ::dsl::Comparison* Expr::mutable_comparison() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dsl::Comparison* _msg = _internal_mutable_comparison();
  // @@protoc_insertion_point(field_mutable:dsl.Expr.comparison)
  return _msg;
}

// .dsl.RangeCheck range = 2;
inline bool Expr::has_range() const {
  return expr_kind_case() == kRange;
}
inline bool Expr::_internal_has_range() const {
  return expr_kind_case() == kRange;
}
inline void Expr::set_has_range() {
  _impl_._oneof_case_[0] = kRange;
}
inline void Expr::clear_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (expr_kind_case() == kRange) {
    if (GetArena() == nullptr) {
      delete _impl_.expr_kind_.range_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.expr_kind_.range_);
    }
    clear_has_expr_kind();
  }
}
inline ::dsl::RangeCheck* Expr::release_range() {
  // @@protoc_insertion_point(field_release:dsl.Expr.range)
  if (expr_kind_case() == kRange) {
    clear_has_expr_kind();
    auto* temp = _impl_.expr_kind_.range_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_kind_.range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dsl::RangeCheck& Expr::_internal_range() const {
  return expr_kind_case() == kRange ? *_impl_.expr_kind_.range_ : reinterpret_cast<::dsl::RangeCheck&>(::dsl::_RangeCheck_default_instance_);
}
inline const ::dsl::RangeCheck& Expr::range() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dsl.Expr.range)
  return _internal_range();
}
inline ::dsl::RangeCheck* Expr::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dsl.Expr.range)
  if (expr_kind_case() == kRange) {
    clear_has_expr_kind();
    auto* temp = _impl_.expr_kind_.range_;
    _impl_.expr_kind_.range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_range(::dsl::RangeCheck* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_expr_kind();
  if (value) {
    set_has_range();
    _impl_.expr_kind_.range_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dsl.Expr.range)
}
inline ::dsl::RangeCheck* Expr::_internal_mutable_range() {
  if (expr_kind_case() != kRange) {
    clear_expr_kind();
    set_has_range();
    _impl_.expr_kind_.range_ =
        ::google::protobuf::Message::DefaultConstruct<::dsl::RangeCheck>(GetArena());
  }
  return _impl_.expr_kind_.range_;
}
inline ::dsl::RangeCheck* Expr::mutable_range() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dsl::RangeCheck* _msg = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:dsl.Expr.range)
  return _msg;
}

// .dsl.Logical logical = 3;
inline bool Expr::has_logical() const {
  return expr_kind_case() == kLogical;
}
inline bool Expr::_internal_has_logical() const {
  return expr_kind_case() == kLogical;
}
inline void Expr::set_has_logical() {
  _impl_._oneof_case_[0] = kLogical;
}
inline void Expr::clear_logical() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (expr_kind_case() == kLogical) {
    if (GetArena() == nullptr) {
      delete _impl_.expr_kind_.logical_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.expr_kind_.logical_);
    }
    clear_has_expr_kind();
  }
}
inline ::dsl::Logical* Expr::release_logical() {
  // @@protoc_insertion_point(field_release:dsl.Expr.logical)
  if (expr_kind_case() == kLogical) {
    clear_has_expr_kind();
    auto* temp = _impl_.expr_kind_.logical_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_kind_.logical_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dsl::Logical& Expr::_internal_logical() const {
  return expr_kind_case() == kLogical ? *_impl_.expr_kind_.logical_ : reinterpret_cast<::dsl::Logical&>(::dsl::_Logical_default_instance_);
}
inline const ::dsl::Logical& Expr::logical() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dsl.Expr.logical)
  return _internal_logical();
}
inline ::dsl::Logical* Expr::unsafe_arena_release_logical() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dsl.Expr.logical)
  if (expr_kind_case() == kLogical) {
    clear_has_expr_kind();
    auto* temp = _impl_.expr_kind_.logical_;
    _impl_.expr_kind_.logical_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_logical(::dsl::Logical* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_expr_kind();
  if (value) {
    set_has_logical();
    _impl_.expr_kind_.logical_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dsl.Expr.logical)
}
inline ::dsl::Logical* Expr::_internal_mutable_logical() {
  if (expr_kind_case() != kLogical) {
    clear_expr_kind();
    set_has_logical();
    _impl_.expr_kind_.logical_ =
        ::google::protobuf::Message::DefaultConstruct<::dsl::Logical>(GetArena());
  }
  return _impl_.expr_kind_.logical_;
}
inline ::dsl::Logical* Expr::mutable_logical() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dsl::Logical* _msg = _internal_mutable_logical();
  // @@protoc_insertion_point(field_mutable:dsl.Expr.logical)
  return _msg;
}

// .dsl.NotExpr not_expr = 4;
inline bool Expr::has_not_expr() const {
  return expr_kind_case() == kNotExpr;
}
inline bool Expr::_internal_has_not_expr() const {
  return expr_kind_case() == kNotExpr;
}
inline void Expr::set_has_not_expr() {
  _impl_._oneof_case_[0] = kNotExpr;
}
inline void Expr::clear_not_expr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (expr_kind_case() == kNotExpr) {
    if (GetArena() == nullptr) {
      delete _impl_.expr_kind_.not_expr_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.expr_kind_.not_expr_);
    }
    clear_has_expr_kind();
  }
}
inline ::dsl::NotExpr* Expr::release_not_expr() {
  // @@protoc_insertion_point(field_release:dsl.Expr.not_expr)
  if (expr_kind_case() == kNotExpr) {
    clear_has_expr_kind();
    auto* temp = _impl_.expr_kind_.not_expr_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_kind_.not_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dsl::NotExpr& Expr::_internal_not_expr() const {
  return expr_kind_case() == kNotExpr ? *_impl_.expr_kind_.not_expr_ : reinterpret_cast<::dsl::NotExpr&>(::dsl::_NotExpr_default_instance_);
}
inline const ::dsl::NotExpr& Expr::not_expr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dsl.Expr.not_expr)
  return _internal_not_expr();
}
inline ::dsl::NotExpr* Expr::unsafe_arena_release_not_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dsl.Expr.not_expr)
  if (expr_kind_case() == kNotExpr) {
    clear_has_expr_kind();
    auto* temp = _impl_.expr_kind_.not_expr_;
    _impl_.expr_kind_.not_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_not_expr(::dsl::NotExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_expr_kind();
  if (value) {
    set_has_not_expr();
    _impl_.expr_kind_.not_expr_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dsl.Expr.not_expr)
}
inline ::dsl::NotExpr* Expr::_internal_mutable_not_expr() {
  if (expr_kind_case() != kNotExpr) {
    clear_expr_kind();
    set_has_not_expr();
    _impl_.expr_kind_.not_expr_ =
        ::google::protobuf::Message::DefaultConstruct<::dsl::NotExpr>(GetArena());
  }
  return _impl_.expr_kind_.not_expr_;
}
inline ::dsl::NotExpr* Expr::mutable_not_expr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dsl::NotExpr* _msg = _internal_mutable_not_expr();
  // @@protoc_insertion_point(field_mutable:dsl.Expr.not_expr)
  return _msg;
}

inline bool Expr::has_expr_kind() const {
  return expr_kind_case() != EXPR_KIND_NOT_SET;
}
inline void Expr::clear_has_expr_kind() {
  _impl_._oneof_case_[0] = EXPR_KIND_NOT_SET;
}
inline Expr::ExprKindCase Expr::expr_kind_case() const {
  return Expr::ExprKindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Comparison

// string column = 1;
inline void Comparison::clear_column() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.column_.ClearToEmpty();
}
inline const std::string& Comparison::column() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dsl.Comparison.column)
  return _internal_column();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Comparison::set_column(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.column_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dsl.Comparison.column)
}
inline std::string* Comparison::mutable_column() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_column();
  // @@protoc_insertion_point(field_mutable:dsl.Comparison.column)
  return _s;
}
inline const std::string& Comparison::_internal_column() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.column_.Get();
}
inline void Comparison::_internal_set_column(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.column_.Set(value, GetArena());
}
inline std::string* Comparison::_internal_mutable_column() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.column_.Mutable( GetArena());
}
inline std::string* Comparison::release_column() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dsl.Comparison.column)
  return _impl_.column_.Release();
}
inline void Comparison::set_allocated_column(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.column_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.column_.IsDefault()) {
    _impl_.column_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dsl.Comparison.column)
}

// .dsl.ComparisonOpType op = 2;
inline void Comparison::clear_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = 0;
}
inline ::dsl::ComparisonOpType Comparison::op() const {
  // @@protoc_insertion_point(field_get:dsl.Comparison.op)
  return _internal_op();
}
inline void Comparison::set_op(::dsl::ComparisonOpType value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:dsl.Comparison.op)
}
inline ::dsl::ComparisonOpType Comparison::_internal_op() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dsl::ComparisonOpType>(_impl_.op_);
}
inline void Comparison::_internal_set_op(::dsl::ComparisonOpType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = value;
}

// string value = 3;
inline void Comparison::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Comparison::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dsl.Comparison.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Comparison::set_value(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dsl.Comparison.value)
}
inline std::string* Comparison::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:dsl.Comparison.value)
  return _s;
}
inline const std::string& Comparison::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_.Get();
}
inline void Comparison::_internal_set_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(value, GetArena());
}
inline std::string* Comparison::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* Comparison::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dsl.Comparison.value)
  return _impl_.value_.Release();
}
inline void Comparison::set_allocated_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dsl.Comparison.value)
}

// -------------------------------------------------------------------

// RangeCheck

// string column = 1;
inline void RangeCheck::clear_column() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.column_.ClearToEmpty();
}
inline const std::string& RangeCheck::column() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dsl.RangeCheck.column)
  return _internal_column();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RangeCheck::set_column(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.column_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dsl.RangeCheck.column)
}
inline std::string* RangeCheck::mutable_column() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_column();
  // @@protoc_insertion_point(field_mutable:dsl.RangeCheck.column)
  return _s;
}
inline const std::string& RangeCheck::_internal_column() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.column_.Get();
}
inline void RangeCheck::_internal_set_column(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.column_.Set(value, GetArena());
}
inline std::string* RangeCheck::_internal_mutable_column() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.column_.Mutable( GetArena());
}
inline std::string* RangeCheck::release_column() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dsl.RangeCheck.column)
  return _impl_.column_.Release();
}
inline void RangeCheck::set_allocated_column(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.column_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.column_.IsDefault()) {
    _impl_.column_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:dsl.RangeCheck.column)
}

// double low = 2;
inline void RangeCheck::clear_low() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.low_ = 0;
}
inline double RangeCheck::low() const {
  // @@protoc_insertion_point(field_get:dsl.RangeCheck.low)
  return _internal_low();
}
inline void RangeCheck::set_low(double value) {
  _internal_set_low(value);
  // @@protoc_insertion_point(field_set:dsl.RangeCheck.low)
}
inline double RangeCheck::_internal_low() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.low_;
}
inline void RangeCheck::_internal_set_low(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.low_ = value;
}

// double high = 3;
inline void RangeCheck::clear_high() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.high_ = 0;
}
inline double RangeCheck::high() const {
  // @@protoc_insertion_point(field_get:dsl.RangeCheck.high)
  return _internal_high();
}
inline void RangeCheck::set_high(double value) {
  _internal_set_high(value);
  // @@protoc_insertion_point(field_set:dsl.RangeCheck.high)
}
inline double RangeCheck::_internal_high() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.high_;
}
inline void RangeCheck::_internal_set_high(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.high_ = value;
}

// -------------------------------------------------------------------

// Logical

// .dsl.LogicOpType op = 1;
inline void Logical::clear_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = 0;
}
inline ::dsl::LogicOpType Logical::op() const {
  // @@protoc_insertion_point(field_get:dsl.Logical.op)
  return _internal_op();
}
inline void Logical::set_op(::dsl::LogicOpType value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:dsl.Logical.op)
}
inline ::dsl::LogicOpType Logical::_internal_op() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::dsl::LogicOpType>(_impl_.op_);
}
inline void Logical::_internal_set_op(::dsl::LogicOpType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = value;
}

// repeated .dsl.Expr operands = 2;
inline int Logical::_internal_operands_size() const {
  return _internal_operands().size();
}
inline int Logical::operands_size() const {
  return _internal_operands_size();
}
inline void Logical::clear_operands() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operands_.Clear();
}
inline ::dsl::Expr* Logical::mutable_operands(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dsl.Logical.operands)
  return _internal_mutable_operands()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::dsl::Expr>* Logical::mutable_operands()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dsl.Logical.operands)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_operands();
}
inline const ::dsl::Expr& Logical::operands(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dsl.Logical.operands)
  return _internal_operands().Get(index);
}
inline ::dsl::Expr* Logical::add_operands() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::dsl::Expr* _add = _internal_mutable_operands()->Add();
  // @@protoc_insertion_point(field_add:dsl.Logical.operands)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::dsl::Expr>& Logical::operands() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dsl.Logical.operands)
  return _internal_operands();
}
inline const ::google::protobuf::RepeatedPtrField<::dsl::Expr>&
Logical::_internal_operands() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.operands_;
}
inline ::google::protobuf::RepeatedPtrField<::dsl::Expr>*
Logical::_internal_mutable_operands() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.operands_;
}

// -------------------------------------------------------------------

// NotExpr

// .dsl.Expr expr = 1;
inline bool NotExpr::has_expr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expr_ != nullptr);
  return value;
}
inline void NotExpr::clear_expr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expr_ != nullptr) _impl_.expr_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::dsl::Expr& NotExpr::_internal_expr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::dsl::Expr* p = _impl_.expr_;
  return p != nullptr ? *p : reinterpret_cast<const ::dsl::Expr&>(::dsl::_Expr_default_instance_);
}
inline const ::dsl::Expr& NotExpr::expr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dsl.NotExpr.expr)
  return _internal_expr();
}
inline void NotExpr::unsafe_arena_set_allocated_expr(::dsl::Expr* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expr_);
  }
  _impl_.expr_ = reinterpret_cast<::dsl::Expr*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dsl.NotExpr.expr)
}
inline ::dsl::Expr* NotExpr::release_expr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dsl::Expr* released = _impl_.expr_;
  _impl_.expr_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::dsl::Expr* NotExpr::unsafe_arena_release_expr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:dsl.NotExpr.expr)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::dsl::Expr* temp = _impl_.expr_;
  _impl_.expr_ = nullptr;
  return temp;
}
inline ::dsl::Expr* NotExpr::_internal_mutable_expr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expr_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dsl::Expr>(GetArena());
    _impl_.expr_ = reinterpret_cast<::dsl::Expr*>(p);
  }
  return _impl_.expr_;
}
inline ::dsl::Expr* NotExpr::mutable_expr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::dsl::Expr* _msg = _internal_mutable_expr();
  // @@protoc_insertion_point(field_mutable:dsl.NotExpr.expr)
  return _msg;
}
inline void NotExpr::set_allocated_expr(::dsl::Expr* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.expr_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.expr_ = reinterpret_cast<::dsl::Expr*>(value);
  // @@protoc_insertion_point(field_set_allocated:dsl.NotExpr.expr)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace dsl


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::dsl::SeverityType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::dsl::SeverityType>() {
  return ::dsl::SeverityType_descriptor();
}
template <>
struct is_proto_enum<::dsl::ComparisonOpType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::dsl::ComparisonOpType>() {
  return ::dsl::ComparisonOpType_descriptor();
}
template <>
struct is_proto_enum<::dsl::LogicOpType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::dsl::LogicOpType>() {
  return ::dsl::LogicOpType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // rules_2eproto_2epb_2eh
